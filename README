<<<<<<< ours
# Factory Floor Map

Interactive, mobile-first 2D factory floor map for locating physical components.

## Quick start (local server)

```bash
npm install
npm start
```

Open `http://localhost:3000`.

The dev server reads `data/components.json` and `data/polygons.json` directly.

## Quick start (static)

```bash
npm install
npm run sync-data
```

Open `public/index.html` in your browser or serve the `public/` folder with any static server.

## Data

- Source of truth: `data/components.json`
- Polygons: `data/polygons.json`
- Static build output: `public/data/components.json`, `public/data/polygons.json` (generated by `npm run sync-data`)

The static client reads `/data/components.json` and `/data/polygons.json` directly when hosted.

### Optional type-split components

You can split components by type in `data/components/*.json` and merge them into `data/components.json`:

```bash
npm run build-components
```

If a component entry omits `type`, the merge step will infer it from the filename (e.g. `hydrants.json` → `Hydrant`).

## Deployment

For static hosting (recommended):

```bash
npm run deploy
```

This syncs `data/*.json` into `public/data/` and runs `firebase deploy`.
=======
# Factory Floor Map

Interactive, mobile-first 2D factory floor map for locating physical components.

## Quick start

```bash
npm install
npm run build-db
npm start
```

Open `http://localhost:3000`.

## Data

Component data lives in `data/components.json` and is compiled into a read-only SQLite database in `data/factory.db` using `npm run build-db`.

The server loads all component records into memory on startup and exposes:

- `GET /components` → `{ version, components }`
- `GET /components/version` → `{ version }`

The client polls the version hash and refetches when it changes.
>>>>>>> theirs
